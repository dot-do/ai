---
$id: https://embeddings.do/examples/real-world-use-case
$type: HowTo
title: Real-World Use Case - embeddings.do
description: Complete e-commerce search implementation with embeddings
keywords: [embeddings, real-world, e-commerce, search, implementation]
author:
  $type: Organization
  name: .do Platform
---

# Real-World Use Case: E-Commerce Search

Complete implementation of semantic product search for an e-commerce platform.

## Overview

Build a production-ready semantic search system with:

- Product indexing with embeddings
- Natural language search
- Filter and facet support
- Caching for performance
- Recommendation engine
- Related products

## System Architecture

```
Products → Index → Cache → Search → Results
                ↓
          Vector DB (Pinecone)
```

## Implementation

### 1. Data Model

```typescript
import { $ } from 'sdk.do'

interface Product {
  $id: string
  $type: 'Product'
  name: string
  description: string
  category: string
  brand: string
  price: number
  features: string[]
  embedding?: number[] // Vector embedding
  embeddingVersion?: number // Track version
}
```

### 2. Indexing Service

```typescript
import { $, ai, db } from 'sdk.do'

class ProductIndexer {
  async indexAll() {
    const products = await db.list($.Product)

    console.log(`Indexing ${products.length} products...`)

    // Process in batches
    const batchSize = 100
    for (let i = 0; i < products.length; i += batchSize) {
      const batch = products.slice(i, i + batchSize)
      await this.indexBatch(batch)

      console.log(`Processed ${i + batch.length}/${products.length}`)
    }

    console.log('Indexing complete!')
  }

  async indexBatch(products: Product[]) {
    // Prepare texts
    const texts = products.map((p) => this.prepareText(p))

    // Generate embeddings
    const embeddings = await ai.embed(texts)

    // Update products
    for (let i = 0; i < products.length; i++) {
      await db.update(products[i].$id, {
        embedding: embeddings[i],
        embeddingVersion: 1,
      })
    }
  }

  private prepareText(product: Product): string {
    return [product.name, product.description, product.category, product.brand, product.features?.join(' ')].filter(Boolean).join(' ').toLowerCase().trim()
  }
}
```

### 3. Search Service

```typescript
import { $, ai, db } from 'sdk.do'

interface SearchOptions {
  query: string
  category?: string
  minPrice?: number
  maxPrice?: number
  brand?: string
  limit?: number
}

class ProductSearch {
  async search(options: SearchOptions) {
    // Generate query embedding
    const queryEmbedding = await ai.embed(options.query)

    // Get products with filters
    const products = await this.getFilteredProducts(options)

    // Calculate similarity
    const results = products
      .map((product) => ({
        product,
        similarity: this.cosineSimilarity(queryEmbedding, product.embedding),
      }))
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, options.limit || 20)

    return results
  }

  private async getFilteredProducts(options: SearchOptions) {
    const where: any = {}

    if (options.category) {
      where.category = options.category
    }

    if (options.minPrice || options.maxPrice) {
      where.price = {}
      if (options.minPrice) where.price.$gte = options.minPrice
      if (options.maxPrice) where.price.$lte = options.maxPrice
    }

    if (options.brand) {
      where.brand = options.brand
    }

    return await db.list($.Product, { where })
  }

  private cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0)
    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0))
    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0))
    return dotProduct / (magnitudeA * magnitudeB)
  }
}
```

### 4. Caching Layer

```typescript
import { ai } from 'sdk.do'

class EmbeddingCache {
  private memoryCache = new Map<string, number[]>()
  private maxSize = 1000

  async get(text: string): Promise<number[] | null> {
    const hash = this.hash(text)

    // Check memory cache
    if (this.memoryCache.has(hash)) {
      return this.memoryCache.get(hash)!
    }

    // Check Redis
    const cached = await redis.get(`embed:${hash}`)
    if (cached) {
      const embedding = JSON.parse(cached)
      this.addToMemory(hash, embedding)
      return embedding
    }

    return null
  }

  async set(text: string, embedding: number[]) {
    const hash = this.hash(text)

    // Store in memory
    this.addToMemory(hash, embedding)

    // Store in Redis (1 hour TTL)
    await redis.set(`embed:${hash}`, JSON.stringify(embedding), 'EX', 3600)
  }

  private addToMemory(key: string, value: number[]) {
    // LRU eviction
    if (this.memoryCache.size >= this.maxSize) {
      const firstKey = this.memoryCache.keys().next().value
      this.memoryCache.delete(firstKey)
    }

    this.memoryCache.set(key, value)
  }

  private hash(text: string): string {
    return text
      .split('')
      .reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0)
      .toString(36)
  }
}
```

### 5. Recommendation Engine

```typescript
import { $, ai, db } from 'sdk.do'

class RecommendationEngine {
  async getRecommendations(userId: string, limit = 5) {
    // Get user's order history
    const orders = await db.list($.Order, {
      where: { customer: userId },
      orderBy: { orderDate: 'desc' },
      limit: 10,
    })

    const purchasedProducts = orders.flatMap((o) => o.orderedItem)

    // Calculate preference embedding
    const preferenceEmbedding = this.averageEmbeddings(purchasedProducts.map((p) => p.embedding))

    // Find similar products
    const allProducts = await db.list($.Product)

    return allProducts
      .filter((p) => !purchasedProducts.some((pp) => pp.$id === p.$id))
      .map((p) => ({
        product: p,
        score: this.cosineSimilarity(preferenceEmbedding, p.embedding),
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, limit)
  }

  async getSimilarProducts(productId: string, limit = 5) {
    const product = await db.get($.Product, productId)
    const allProducts = await db.list($.Product)

    return allProducts
      .filter((p) => p.$id !== productId && p.category === product.category)
      .map((p) => ({
        product: p,
        similarity: this.cosineSimilarity(product.embedding, p.embedding),
      }))
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, limit)
  }

  private averageEmbeddings(embeddings: number[][]): number[] {
    const dims = embeddings[0].length
    const avg = new Array(dims).fill(0)

    for (const embedding of embeddings) {
      for (let i = 0; i < dims; i++) {
        avg[i] += embedding[i]
      }
    }

    return avg.map((v) => v / embeddings.length)
  }

  private cosineSimilarity(a: number[], b: number[]): number {
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0)
    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0))
    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0))
    return dotProduct / (magnitudeA * magnitudeB)
  }
}
```

### 6. API Routes

```typescript
import { Hono } from 'hono'

const app = new Hono()

const search = new ProductSearch()
const recommendations = new RecommendationEngine()
const cache = new EmbeddingCache()

// Search endpoint
app.get('/api/search', async (c) => {
  const query = c.req.query('q')
  const category = c.req.query('category')
  const minPrice = c.req.query('minPrice')
  const maxPrice = c.req.query('maxPrice')
  const limit = parseInt(c.req.query('limit') || '20')

  const results = await search.search({
    query,
    category,
    minPrice: minPrice ? parseFloat(minPrice) : undefined,
    maxPrice: maxPrice ? parseFloat(maxPrice) : undefined,
    limit,
  })

  return c.json({ results })
})

// Recommendations endpoint
app.get('/api/recommendations/:userId', async (c) => {
  const userId = c.req.param('userId')
  const limit = parseInt(c.req.query('limit') || '5')

  const recommendations = await recommendations.getRecommendations(userId, limit)

  return c.json({ recommendations })
})

// Similar products endpoint
app.get('/api/similar/:productId', async (c) => {
  const productId = c.req.param('productId')
  const limit = parseInt(c.req.query('limit') || '5')

  const similar = await recommendations.getSimilarProducts(productId, limit)

  return c.json({ similar })
})

export default app
```

### 7. Auto-Indexing on Events

```typescript
import { $, ai, db, on } from 'sdk.do'

// Index when product is created
on($.Product.created, async (event) => {
  const product = event.data

  const text = [product.name, product.description, product.category, product.brand].join(' ')

  const embedding = await ai.embed(text)

  await db.update(product.$id, {
    embedding,
    embeddingVersion: 1,
  })
})

// Reindex when product is updated
on($.Product.updated, async (event) => {
  const product = event.data

  const text = [product.name, product.description, product.category, product.brand].join(' ')

  const embedding = await ai.embed(text)

  await db.update(product.$id, {
    embedding,
    embeddingVersion: (product.embeddingVersion || 0) + 1,
  })
})
```

## Usage Examples

### Search

```typescript
// Natural language search
const results = await search.search({
  query: 'affordable laptop for programming',
  category: 'Electronics',
  maxPrice: 1000,
  limit: 20,
})

console.log(`Found ${results.length} results`)
results.forEach((r) => {
  console.log(`${r.product.name} - ${r.similarity.toFixed(3)}`)
})
```

### Recommendations

```typescript
// Get personalized recommendations
const recs = await recommendations.getRecommendations('user_123', 5)

console.log('Recommended products:')
recs.forEach((r) => {
  console.log(`${r.product.name} - Score: ${r.score.toFixed(3)}`)
})
```

### Similar Products

```typescript
// Find similar products
const similar = await recommendations.getSimilarProducts('prod_456', 5)

console.log('Similar products:')
similar.forEach((s) => {
  console.log(`${s.product.name} - ${s.similarity.toFixed(3)}`)
})
```

## Performance Metrics

- **Indexing**: ~2 seconds per 100 products
- **Search**: < 100ms for 10,000 products (with cache)
- **Recommendations**: < 50ms (with cached embeddings)
- **Cache hit rate**: 85-90%

## License

CC-BY-4.0 (Open Source)
