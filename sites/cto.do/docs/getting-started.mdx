---
$id: https://cto.do/docs/getting-started
$type: TechArticle
title: Getting Started with cto.do
description: Learn how to build your first autonomous CTO agent for technical leadership and strategic decision-making
keywords: [getting started, CTO agent, technical leadership, architecture decisions, engineering management]
author:
  $type: Organization
  name: .do Platform
---

# Getting Started with cto.do

Build your first autonomous CTO agent in 10 minutes.

## Installation

```bash
pnpm add sdk.do
```

## Your First CTO Agent

Let's create a CTO agent that can evaluate technology decisions and provide strategic recommendations.

### Step 1: Import SDK

```typescript
import $, { agent } from 'sdk.do'
```

### Step 2: Define CTO Agent

```typescript
const cto = await agent.create({
  $type: 'Agent',
  $role: $.ChiefTechnologyOfficer,
  name: 'Alex Chen',
  title: 'Chief Technology Officer',
  persona: {
    background: '15 years in software engineering, 8 years in technical leadership roles',
    previous_roles: ['Principal Engineer at Google', 'VP Engineering at Series B startup'],
    expertise: ['distributed systems', 'cloud architecture', 'engineering management', 'technology strategy', 'security and compliance'],
    leadership_style: 'Servant leader, data-driven decision maker, strong communicator',
    technical_depth: 'Deep systems knowledge with hands-on coding background',
    business_acumen: 'Strong understanding of SaaS economics and business models',
  },
  capabilities: [
    'architecture_design',
    'technology_evaluation',
    'team_leadership',
    'strategic_planning',
    'vendor_selection',
    'security_compliance',
    'performance_optimization',
    'cost_optimization',
  ],
  tools: ['github', 'aws', 'datadog', 'jira', 'confluence', 'slack', 'figma'],
  model: 'claude-sonnet-4.5',
  temperature: 0.7,
})
```

### Step 3: Execute CTO Task

```typescript
const decision = await cto.execute({
  task: 'Evaluate whether to migrate from monolith to microservices',
  context: {
    company: {
      stage: 'Series B',
      revenue: '$10M ARR',
      growth_rate: '3x YoY',
      team_size: 50,
    },
    engineering: {
      current_architecture: 'Ruby on Rails monolith',
      team_size: 40,
      deployment_frequency: '2x per week',
      incident_rate: '3 per week',
    },
    pain_points: ['Slow deployment cycles', 'Difficult to scale team across codebase', 'Database becoming bottleneck', 'Hard to adopt new technologies'],
    constraints: {
      timeline: '6 months',
      budget: '$500K',
      downtime_tolerance: 'Zero downtime requirement',
      team_expertise: 'Strong Rails, limited microservices experience',
    },
  },
})

console.log(decision)
```

**Example Output:**

```json
{
  "decision": "Recommend phased migration to microservices",
  "rationale": {
    "key_drivers": [
      "Team scaling challenges justify distributed ownership",
      "Growth trajectory will exceed monolith capacity in 12 months",
      "Deployment bottlenecks impacting feature velocity",
      "Database scalability concerns require architectural changes"
    ],
    "risk_assessment": {
      "technical_risks": [
        {
          "risk": "Increased operational complexity",
          "likelihood": "High",
          "impact": "Medium",
          "mitigation": "Invest in observability platform, hire DevOps engineers"
        },
        {
          "risk": "Data consistency challenges",
          "likelihood": "Medium",
          "impact": "High",
          "mitigation": "Event-driven architecture with saga pattern"
        }
      ],
      "business_risks": [
        {
          "risk": "Reduced feature velocity during migration",
          "likelihood": "High",
          "impact": "Medium",
          "mitigation": "Phased approach, continue parallel development"
        }
      ]
    }
  },
  "recommendation": {
    "approach": "Strangler Fig Pattern - Phased Migration",
    "phases": [
      {
        "phase": 1,
        "duration": "6 weeks",
        "goal": "Extract authentication service",
        "rationale": "Self-contained, clear boundaries, high impact",
        "deliverables": ["Auth microservice in Node.js", "API gateway for routing", "Service mesh for observability"],
        "team": "4 senior engineers",
        "success_metrics": {
          "auth_latency": "<100ms p99",
          "availability": ">99.9%",
          "zero_downtime_cutover": true
        }
      },
      {
        "phase": 2,
        "duration": "8 weeks",
        "goal": "Extract payment processing service",
        "rationale": "Critical path, clear domain boundaries, compliance isolation",
        "team": "6 engineers",
        "success_metrics": {
          "payment_success_rate": ">99.5%",
          "pci_compliance": "Isolated service"
        }
      },
      {
        "phase": 3,
        "duration": "10 weeks",
        "goal": "Extract notification service",
        "rationale": "High volume, resource intensive, good async candidate",
        "team": "4 engineers"
      }
    ],
    "timeline": "6 months for phase 1-3, 12 months for full migration",
    "budget_breakdown": {
      "infrastructure": "$150K (Kubernetes, service mesh, observability)",
      "tooling": "$50K (CI/CD, monitoring, APM)",
      "hiring": "$200K (2 DevOps engineers, 1 Solutions Architect)",
      "training": "$50K (Microservices workshops, cloud certifications)",
      "buffer": "$50K",
      "total": "$500K"
    }
  },
  "architecture": {
    "target_state": {
      "services": ["Auth Service (Node.js)", "Payment Service (Go)", "Notification Service (Python)", "Core Monolith (Rails - gradually extract)"],
      "infrastructure": "Kubernetes on AWS EKS",
      "api_gateway": "Kong",
      "service_mesh": "Istio",
      "messaging": "Kafka for async communication",
      "observability": "Datadog for metrics/logs/traces",
      "databases": "PostgreSQL (per service), shared data via events"
    },
    "principles": [
      "Service autonomy - own database, deploy independently",
      "API-first design - well-defined service contracts",
      "Event-driven - async communication where possible",
      "Observability built-in - structured logging, metrics, traces",
      "Security by default - mTLS, API authentication, least privilege"
    ]
  },
  "success_criteria": {
    "deployment_frequency": "10x per day (up from 2x per week)",
    "incident_rate": "Reduce by 50%",
    "team_velocity": "40% increase after 6 months",
    "time_to_onboard": "Reduce from 4 weeks to 1 week",
    "database_performance": "Handle 10x traffic without degradation"
  },
  "alternatives_considered": [
    {
      "option": "Stay with monolith",
      "pros": ["Lower complexity", "No migration cost", "Team expertise"],
      "cons": ["Scaling limits", "Team coordination issues", "Technical debt grows"],
      "verdict": "Not viable for 3x YoY growth trajectory"
    },
    {
      "option": "Rewrite from scratch",
      "pros": ["Modern architecture", "Clean slate"],
      "cons": ["18+ month timeline", "High risk", "Feature development halts"],
      "verdict": "Too risky for business continuity"
    },
    {
      "option": "Modular monolith",
      "pros": ["Lower operational complexity", "Faster path"],
      "cons": ["Doesn't solve database scaling", "Team coordination still difficult"],
      "verdict": "Delays inevitable migration"
    }
  ],
  "next_steps": [
    "Present recommendation to executive team and board",
    "Hire Solutions Architect to lead migration",
    "Begin hiring 2 DevOps engineers",
    "Create detailed technical design for Phase 1",
    "Set up infrastructure (EKS cluster, API gateway, observability)",
    "Training: Microservices architecture workshop for team",
    "Kickoff Phase 1: Authentication service extraction"
  ]
}
```

## Understanding CTO Agent Decision-Making

CTO agents make strategic decisions by analyzing multiple dimensions:

### 1. Technical Assessment

```typescript
// Agent evaluates technical factors
const technicalAnalysis = {
  current_state: 'Analyze existing architecture, tech stack, team capabilities',
  requirements: 'Understand scalability, performance, security needs',
  constraints: 'Consider timeline, budget, team expertise',
  options: 'Research and evaluate alternative approaches',
  trade_offs: 'Weigh pros/cons of each option',
}
```

### 2. Business Context

```typescript
// Agent considers business implications
const businessContext = {
  company_stage: 'Startup vs scale-up vs enterprise',
  growth_trajectory: 'Growth rate and scalability needs',
  competitive_landscape: 'Time to market pressure',
  financial_constraints: 'Budget and ROI requirements',
  risk_tolerance: 'Acceptable level of technical risk',
}
```

### 3. Team Dynamics

```typescript
// Agent factors in team capabilities
const teamAnalysis = {
  current_expertise: 'Assess team skills and experience',
  learning_capacity: 'Ability to adopt new technologies',
  organizational_structure: 'Team size and composition',
  culture: 'Innovation mindset vs stability preference',
  retention_risk: 'Impact on morale and retention',
}
```

### 4. Strategic Alignment

```typescript
// Agent ensures alignment with company vision
const strategicAlignment = {
  product_roadmap: 'Support upcoming product features',
  hiring_plan: 'Enable team growth',
  market_positioning: 'Competitive differentiation',
  technical_vision: 'Long-term technology direction',
  innovation_goals: 'Balance innovation with stability',
}
```

## Common CTO Agent Tasks

### Technology Evaluation

```typescript
// Evaluate new technology adoption
const evaluation = await cto.execute({
  task: 'Should we adopt GraphQL for our API?',
  context: {
    current_api: 'REST API with 50 endpoints',
    clients: ['Web app', 'Mobile app', 'Partner integrations'],
    team_size: 15,
    pain_points: ['Over-fetching', 'Multiple roundtrips', 'API versioning'],
  },
})
```

### Architecture Review

```typescript
// Review architecture proposal
const review = await cto.execute({
  task: 'Review architecture proposal for real-time notifications',
  proposal: {
    technology: 'WebSockets with Socket.io',
    infrastructure: 'Separate Node.js service',
    scaling: 'Redis pub/sub for multi-instance',
    estimated_cost: '$5K/month',
    team_estimate: '6 weeks',
  },
  context: {
    requirements: '100K concurrent connections, <100ms latency',
    existing_stack: 'Rails monolith, PostgreSQL, Redis',
  },
})
```

### Team Structure Optimization

```typescript
// Analyze and optimize team structure
const teamOptimization = await cto.execute({
  task: 'Optimize engineering team structure for growth',
  context: {
    current_state: {
      team_size: 30,
      structure: '3 product teams, 1 platform team',
      challenges: ['Cross-team dependencies', 'Uneven workload', 'Knowledge silos'],
    },
    growth_plan: 'Hire 20 engineers over next 6 months',
    product_roadmap: ['New mobile app', 'API platform', 'Enterprise features'],
  },
})
```

### Security and Compliance Planning

```typescript
// Plan security compliance initiative
const compliancePlan = await cto.execute({
  task: 'Create SOC 2 Type II compliance roadmap',
  context: {
    current_state: 'No formal security program',
    deadline: '6 months (required for enterprise deals)',
    budget: '$200K',
    team: 'No dedicated security engineer',
  },
})
```

### Build vs Buy Decisions

```typescript
// Decide whether to build or buy
const buildVsBuy = await cto.execute({
  task: 'Build custom analytics platform vs buy existing solution',
  requirements: ['Custom events tracking', 'Real-time dashboards', '5-year data retention', 'Team of analysts need SQL access'],
  options: [
    { option: 'Build custom (Clickhouse + Metabase)', cost: '$300K', timeline: '6 months' },
    { option: 'Buy Mixpanel Enterprise', cost: '$100K/year', timeline: '2 weeks' },
    { option: 'Buy Amplitude', cost: '$150K/year', timeline: '2 weeks' },
  ],
})
```

## Configuration Options

### Model Configuration

```typescript
await cto.configure({
  // Model settings
  model: 'claude-sonnet-4.5',
  temperature: 0.7, // Balance creativity with consistency
  maxTokens: 8192, // Allow for detailed analysis

  // Thinking depth
  reasoning_steps: 5, // Multi-step reasoning for complex decisions
  consider_alternatives: true, // Always evaluate alternatives
  trade_off_analysis: true, // Explicit trade-off comparison
})
```

### Decision Framework

```typescript
await cto.configure({
  decision_framework: {
    // Decision criteria and weighting
    criteria: {
      technical_feasibility: 0.25,
      business_impact: 0.25,
      team_capability: 0.2,
      cost_effectiveness: 0.15,
      time_to_market: 0.15,
    },

    // Risk tolerance
    risk_appetite: 'moderate', // 'conservative' | 'moderate' | 'aggressive'

    // Strategic priorities
    priorities: ['scalability', 'team_growth', 'time_to_market'],

    // Constraints
    hard_constraints: ['zero_downtime', 'budget_cap', 'team_capacity'],
  },
})
```

### Communication Style

```typescript
await cto.configure({
  communication: {
    // Technical depth
    technical_detail: 'high', // 'low' | 'medium' | 'high'

    // Audience adaptation
    adapt_to_audience: true, // Simplify for non-technical stakeholders

    // Report format
    report_format: {
      executive_summary: true, // Always include exec summary
      technical_details: true, // Include technical appendix
      visual_aids: true, // Include diagrams and charts
      action_items: true, // Clear next steps
    },
  },
})
```

## Monitoring and Observability

### Track CTO Agent Decisions

```typescript
// Monitor agent decision-making
cto.on('decision_made', (event) => {
  console.log(`Decision: ${event.decision}`)
  console.log(`Confidence: ${event.confidence}`)
  console.log(`Alternatives considered: ${event.alternatives.length}`)

  // Log to analytics
  analytics.track('cto_decision', {
    category: event.category,
    confidence: event.confidence,
    execution_time: event.duration,
  })
})
```

### Decision Quality Metrics

```typescript
// Analyze decision quality over time
const metrics = await cto.getMetrics({
  timeframe: 'last_quarter',
})

console.log(metrics)
// {
//   decisions_made: 45,
//   categories: {
//     architecture: 15,
//     technology_evaluation: 12,
//     team_structure: 8,
//     vendor_selection: 10
//   },
//   avg_confidence: 0.82,
//   decision_outcomes: {
//     successful: 38,
//     needs_revision: 5,
//     rejected: 2
//   },
//   stakeholder_satisfaction: 4.5 / 5
// }
```

### Feedback Loop

```typescript
// Provide feedback to improve agent
await cto.provideFeedback({
  decision_id: 'dec_123',
  outcome: 'successful',
  actual_results: {
    timeline: 'Completed 2 weeks early',
    budget: 'Under budget by 10%',
    quality: 'Exceeded performance targets',
  },
  lessons_learned: [
    'Team adapted to new technology faster than expected',
    'Early investment in observability paid off',
    'Documentation was critical for onboarding',
  ],
})
```

## Best Practices

### 1. Provide Rich Context

```typescript
// Good: Comprehensive context
const decision = await cto.execute({
  task: 'Evaluate caching strategy',
  context: {
    system: {
      architecture: 'Microservices',
      scale: '10M requests/day',
      current_caching: 'Application-level with Redis',
    },
    problem: 'Database CPU at 80%, query latency p95 > 500ms',
    business_impact: '$50K/month in overprovisioned DB capacity',
    constraints: {
      budget: '$20K/month for caching solution',
      team_expertise: 'Strong Redis, no CDN experience',
    },
    requirements: {
      target_latency: 'p95 < 100ms',
      cache_hit_rate: '>80%',
      invalidation: 'Real-time when data changes',
    },
  },
})

// Avoid: Vague context
const decision = await cto.execute({
  task: 'Fix performance issues',
  context: { problem: 'Slow queries' },
})
```

### 2. Start with Strategic Questions

```typescript
// Use CTO agent for strategic decisions
const strategicDecisions = [
  'Should we migrate to Kubernetes?',
  'Build vs buy for feature X?',
  'How to structure team for growth?',
  'Which database for new service?',
  'Evaluate vendor for observability',
]

// Use specialized agents for tactical work
const tacticalWork = [
  'Fix specific bug', // → swe.do
  'Review pull request', // → programmers.do
  'Write documentation', // → swe.do
]
```

### 3. Iterate on Decisions

```typescript
// Get initial recommendation
const initial = await cto.execute({
  task: 'Evaluate microservices migration',
})

// Refine based on stakeholder feedback
const refined = await cto.execute({
  task: 'Refine microservices migration plan',
  context: {
    initial_recommendation: initial,
    stakeholder_feedback: {
      ceo: 'Concerned about timeline impact on Q2 OKRs',
      cfo: 'Budget seems high, any cost optimization?',
      vp_eng: 'Team may not have bandwidth during launch',
    },
  },
})

// Final decision with constraints
const final = await cto.execute({
  task: 'Finalize migration plan',
  context: {
    previous_iterations: [initial, refined],
    hard_constraints: ['Must not impact Q2 product launch', 'Reduce budget to $300K', 'Limit team allocation to 4 engineers'],
  },
})
```

### 4. Document Decision Rationale

```typescript
// Capture decision rationale for future reference
const decision = await cto.execute({
  task: 'Choose between PostgreSQL and MongoDB',
  context: {
    /* context */
  },
})

// Store decision record
await db.create($.ArchitectureDecisionRecord, {
  $id: 'adr-001',
  title: 'Use PostgreSQL for primary database',
  date: new Date(),
  status: 'accepted',
  context: decision.context,
  decision: decision.recommendation,
  rationale: decision.rationale,
  consequences: decision.trade_offs,
  alternatives: decision.alternatives_considered,
  stakeholders: ['CTO', 'Engineering Team', 'Product Team'],
})
```

## Troubleshooting

### Agent Provides Generic Advice

**Problem**: CTO agent gives surface-level recommendations

**Solution**: Provide more specific context

```typescript
// Add specific metrics and constraints
context: {
  current_metrics: {
    db_cpu: '80%',
    query_p95: '500ms',
    cache_hit_rate: '60%',
    monthly_cost: '$10K'
  },
  growth_projection: '3x traffic in 6 months',
  team_capacity: '2 backend engineers available',
  deadline: 'Must improve before Q2 launch (8 weeks)'
}
```

### Agent Recommends Unfeasible Solutions

**Problem**: Recommendations don't account for team capabilities

**Solution**: Include team context

```typescript
context: {
  team: {
    size: 15,
    expertise: {
      rails: 'expert',
      react: 'proficient',
      kubernetes: 'beginner',
      go: 'none'
    },
    recent_hires: 5,
    churn_rate: 'low',
    learning_capacity: 'One major new technology per quarter'
  }
}
```

### Decisions Lack Business Justification

**Problem**: Technical recommendations without ROI analysis

**Solution**: Include business metrics

```typescript
context: {
  business: {
    arr: '$10M',
    growth_rate: '3x YoY',
    gross_margin: '80%',
    engineering_cost: '$5M/year',
    target_margin: '70%',
    enterprise_deals_blocked_by: ['SOC 2', 'HIPAA compliance']
  }
}
```

## Next Steps

- [Architecture](./architecture) - Understand CTO agent architecture
- [Best Practices](./best-practices) - Advanced CTO agent patterns
- [API Reference](../api/) - Complete API documentation
- [Examples](../examples/) - Real-world CTO scenarios

---

Ready to lead your engineering organization with autonomous CTO agents? Let's dive into [architecture](./architecture).
