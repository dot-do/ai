---
$id: https://workers.do/examples/real-world-use-case
$type: TechArticle
title: Worker Fleet Real-World Use Case
description: Real-world use case for worker fleet management
keywords: [workers, real-world, use case, production]
author:
  $type: Organization
  name: .do Platform
---

# Real-World Use Case

Production implementation of worker fleet management for a customer support platform.

## Scenario

A SaaS company needs to handle 10,000+ customer support tickets per day with variable demand patterns.

## Implementation

### 1. Create Support Fleet

```typescript
import { $, workers } from 'sdk.do'

const supportFleet = await workers.createFleet({
  name: 'Customer Support Fleet',
  workerTemplate: {
    role: $.SupportAgent,
    capabilities: ['ticket_triage', 'issue_resolution', 'escalation'],
    model: 'claude-sonnet-4.5',
  },
  scaling: {
    min: 20,
    max: 200,
    metric: 'queue_depth',
    target: 50, // tickets per worker
  },
})
```

### 2. Intelligent Routing

```typescript
import { $, workers, on } from 'sdk.do'

on($.Ticket.created, async (event) => {
  const ticket = event.ticket

  // Route based on priority and complexity
  const routing = ticket.priority === 'urgent' ? 'best_performer' : 'load_balanced'

  await supportFleet.assignWork({
    tasks: [ticket],
    distribution: routing,
    filters: {
      capabilities: getRequiredCapabilities(ticket),
    },
  })
})
```

### 3. Auto-Scaling Based on Demand

```typescript
import { $, workers, every } from 'sdk.do'

// Dynamic scaling every minute
every($.EveryMinute, async () => {
  const metrics = await supportFleet.getMetrics()
  const queueDepth = metrics.queueDepth
  const activeWorkers = metrics.activeWorkers
  const avgTicketsPerWorker = queueDepth / activeWorkers

  // Scale up if overwhelmed
  if (avgTicketsPerWorker > 75) {
    const needed = Math.ceil((queueDepth - activeWorkers * 50) / 50)
    await supportFleet.scale({ delta: Math.min(needed, 20) })
  }

  // Scale down if underutilized
  if (avgTicketsPerWorker < 25 && activeWorkers > supportFleet.config.scaling.min) {
    await supportFleet.scale({ delta: -5 })
  }
})
```

### 4. Performance Monitoring

```typescript
import { $, workers, send, every } from 'sdk.do'

// Hourly performance reports
every($.Hourly, async () => {
  const metrics = await supportFleet.getMetrics()

  await send($.Report.generated, {
    type: 'fleet_performance',
    data: {
      activeWorkers: metrics.activeWorkers,
      ticketsResolved: metrics.tasksCompleted,
      avgResolutionTime: metrics.avgCompletionTime,
      customerSatisfaction: metrics.avgSatisfactionScore,
      costPerTicket: metrics.totalCost / metrics.tasksCompleted,
    },
  })

  // Alert if SLA at risk
  if (metrics.avgCompletionTime > 300) {
    // 5 minutes
    await send($.Alert.created, {
      severity: 'critical',
      message: 'Support SLA at risk - high resolution times',
      action: 'scale_up_immediately',
    })
  }
})
```

## Results

- **10,000+ tickets/day** handled automatically
- **<3 min avg resolution time** maintained
- **92% customer satisfaction** score
- **40% cost reduction** vs human agents
- **24/7 availability** with consistent quality

## License

MIT (Open Source)
