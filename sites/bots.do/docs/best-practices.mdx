---
$id: https://bots.do/docs/best-practices
$type: TechArticle
title: Bot Development Best Practices
description: Best practices for building reliable, scalable, and maintainable digital worker bots with bots.do.
keywords: [best practices, bot development, reliability, scalability, maintainability]
author:
  $type: Organization
  name: .do Platform
---

# Bot Development Best Practices

Follow these best practices to build reliable, scalable, and maintainable bots.

## Design Principles

### 1. Single Responsibility

Each bot should have one clear purpose:

```typescript
// Good: Focused bot
const emailBot = await bot.create({
  name: 'Email Sender Bot',
  task: 'Send emails',
  capabilities: ['email_sending', 'template_rendering'],
})

// Bad: Bot doing too much
const megaBot = await bot.create({
  name: 'Everything Bot',
  task: 'Do everything', // Too vague!
  capabilities: ['email', 'sms', 'database', 'api', 'analytics'], // Too many!
})
```

### 2. Idempotency

Ensure operations can be safely retried:

```typescript
const idempotentBot = await bot.create({
  name: 'Idempotent Bot',
  handler: async (task) => {
    // Check if already processed
    const existing = await db.get($.Task, task.id)
    if (existing?.status === 'completed') {
      return existing.result // Return cached result
    }

    // Process task
    const result = await processTask(task)

    // Store result atomically
    await db.create($.Task, {
      id: task.id,
      status: 'completed',
      result,
    })

    return result
  },
})
```

### 3. Graceful Degradation

Handle failures gracefully:

```typescript
const resilientBot = await bot.create({
  name: 'Resilient Bot',
  handler: async (task) => {
    try {
      // Try primary method
      return await primaryProcessor(task)
    } catch (error) {
      console.warn('Primary failed, trying fallback:', error)

      try {
        // Try fallback method
        return await fallbackProcessor(task)
      } catch (fallbackError) {
        // Last resort: queue for manual review
        await queueForReview(task)
        throw new Error('Both primary and fallback failed')
      }
    }
  },
})
```

## Performance Best Practices

### Batch Processing

Process items in batches for efficiency:

```typescript
const batchBot = await bot.create({
  name: 'Batch Processor',
  batching: {
    size: 100, // Process 100 at once
    timeout: 5000, // Or wait 5s
  },
  handler: async (batch) => {
    // Single database call for all items
    return await db.bulkInsert($.Item, batch)
  },
})
```

### Connection Reuse

Reuse connections instead of creating new ones:

```typescript
const efficientBot = await bot.create({
  name: 'Efficient Bot',
  connections: {
    database: {
      pool: { min: 2, max: 10 },
      reuse: true,
    },
    api: {
      keepAlive: true,
      maxSockets: 50,
    },
  },
})
```

### Caching

Cache frequently accessed data:

```typescript
const cachedBot = await bot.create({
  name: 'Cached Bot',
  caching: {
    strategy: 'lru',
    maxSize: 1000,
    ttl: 3600,
  },
  handler: async (input, cache) => {
    const key = `config:${input.type}`

    // Check cache
    if (await cache.has(key)) {
      return await cache.get(key)
    }

    // Fetch and cache
    const config = await fetchConfig(input.type)
    await cache.set(key, config)
    return config
  },
})
```

## Reliability Best Practices

### Retry Logic

Implement exponential backoff with jitter:

```typescript
const retryBot = await bot.create({
  name: 'Retry Bot',
  errorHandling: {
    retry: {
      attempts: 5,
      backoff: 'exponential',
      maxDelay: 30000,
      jitter: true, // Prevents thundering herd
      retryOn: ['TIMEOUT', 'CONNECTION_ERROR', 'RATE_LIMIT'],
    },
  },
})
```

### Circuit Breaker

Prevent cascading failures:

```typescript
const protectedBot = await bot.create({
  name: 'Protected Bot',
  errorHandling: {
    circuitBreaker: {
      threshold: 5, // Open after 5 failures
      timeout: 60000, // Try again after 60s
      halfOpenRequests: 3,
    },
  },
})
```

### Health Checks

Implement health checks:

```typescript
const healthyBot = await bot.create({
  name: 'Healthy Bot',
  health: {
    enabled: true,
    interval: 30000, // Check every 30s
    checks: [
      {
        name: 'database',
        check: async () => {
          const result = await db.query('SELECT 1')
          return result !== null
        },
      },
      {
        name: 'api',
        check: async () => {
          const response = await fetch('https://api.example.com/health')
          return response.ok
        },
      },
    ],
  },
})
```

## Monitoring Best Practices

### Structured Logging

Use structured logging for better observability:

```typescript
const loggingBot = await bot.create({
  name: 'Logging Bot',
  logging: {
    level: 'info',
    format: 'json',
    fields: {
      botId: true,
      taskId: true,
      timestamp: true,
      duration: true,
      status: true,
    },
  },
  handler: async (task, logger) => {
    logger.info('Task started', {
      taskType: task.type,
      taskSize: task.data.length,
    })

    const result = await processTask(task)

    logger.info('Task completed', {
      taskType: task.type,
      resultSize: result.length,
    })

    return result
  },
})
```

### Metrics Collection

Track key performance indicators:

```typescript
const metricsBot = await bot.create({
  name: 'Metrics Bot',
  metrics: {
    collect: [
      'throughput', // Tasks per second
      'latency', // Processing time
      'error_rate', // Percentage of failures
      'success_rate', // Percentage of successes
      'queue_depth', // Backlog size
    ],
    interval: 60000,
  },
})

// Access metrics
const metrics = await metricsBot.getMetrics()
```

### Alerting

Set up proactive alerts:

```typescript
const alertBot = await bot.create({
  name: 'Alert Bot',
  alerts: {
    errorRate: {
      threshold: 5, // Alert if > 5% errors
      window: '5m',
      channels: ['slack', 'pagerduty'],
    },
    latency: {
      threshold: 5000, // Alert if > 5s
      percentile: 95,
      channels: ['slack'],
    },
    queueDepth: {
      threshold: 1000, // Alert if > 1000 items
      channels: ['slack'],
    },
  },
})
```

## Security Best Practices

### Input Validation

Always validate inputs:

```typescript
const validatingBot = await bot.create({
  name: 'Validating Bot',
  validation: {
    schema: {
      type: 'object',
      required: ['id', 'type', 'data'],
      properties: {
        id: { type: 'string', pattern: '^[0-9a-f]{24}$' },
        type: { type: 'string', enum: ['order', 'payment'] },
        data: { type: 'object' },
      },
    },
    strict: true,
  },
  handler: async (input) => {
    // Input is validated before handler
    return await processValidInput(input)
  },
})
```

### Secrets Management

Never hardcode secrets:

```typescript
// Bad
const badBot = await bot.create({
  apiKey: 'sk_live_abc123', // Never do this!
})

// Good
const goodBot = await bot.create({
  name: 'Secure Bot',
  secrets: {
    apiKey: { source: 'vault', key: 'api_key' },
  },
})
```

### Rate Limiting

Implement rate limiting:

```typescript
const rateLimitedBot = await bot.create({
  name: 'Rate Limited Bot',
  rateLimiting: {
    requests: 100, // 100 requests
    window: 60000, // per minute
    strategy: 'sliding-window',
  },
})
```

## Testing Best Practices

### Unit Testing

Test bot logic in isolation:

```typescript
import { describe, it, expect } from 'vitest'
import { bot } from 'sdk.do'

describe('EmailBot', () => {
  it('should send email successfully', async () => {
    const emailBot = await bot.create({
      name: 'Test Bot',
      handler: mockHandler,
    })

    const result = await emailBot.execute({
      to: 'test@example.com',
      subject: 'Test',
      body: 'Test message',
    })

    expect(result.status).toBe('sent')
  })

  it('should handle failures gracefully', async () => {
    // Test error scenarios
  })
})
```

### Integration Testing

Test bot with real dependencies:

```typescript
describe('OrderBot Integration', () => {
  it('should process order end-to-end', async () => {
    const orderBot = await bot.create({
      name: 'Order Bot',
      // Use test database
      connections: {
        database: testDb,
      },
    })

    const result = await orderBot.execute({
      order: testOrder,
    })

    expect(result.status).toBe('completed')

    // Verify side effects
    const stored = await testDb.get($.Order, testOrder.id)
    expect(stored).toBeDefined()
  })
})
```

### Load Testing

Test bot under load:

```typescript
import { describe, it } from 'vitest'

describe('Bot Performance', () => {
  it('should handle 1000 tasks per minute', async () => {
    const bot = await createTestBot()

    const tasks = Array.from({ length: 1000 }, (_, i) => ({
      id: `task-${i}`,
      data: `test-${i}`,
    }))

    const start = Date.now()
    const results = await Promise.all(tasks.map((task) => bot.execute(task)))
    const duration = Date.now() - start

    expect(duration).toBeLessThan(60000) // Within 1 minute
    expect(results.every((r) => r.success)).toBe(true)
  })
})
```

## Deployment Best Practices

### Environment Configuration

Use environment-specific configurations:

```typescript
const config = {
  development: {
    concurrency: 1,
    logLevel: 'debug',
    retries: 1,
  },
  staging: {
    concurrency: 3,
    logLevel: 'info',
    retries: 3,
  },
  production: {
    concurrency: 10,
    logLevel: 'warn',
    retries: 5,
  },
}

const bot = await bot.create({
  name: 'Configured Bot',
  ...config[process.env.NODE_ENV],
})
```

### Gradual Rollout

Deploy changes gradually:

```typescript
const bot = await bot.create({
  name: 'Canary Bot',
  deployment: {
    strategy: 'canary',
    canary: {
      percentage: 10, // Route 10% to new version
      duration: 3600, // Monitor for 1 hour
      metrics: ['error_rate', 'latency'],
      rollback: {
        automatic: true,
        threshold: {
          error_rate: 5, // Rollback if > 5% errors
          latency: 2000, // Rollback if > 2s latency
        },
      },
    },
  },
})
```

### Blue-Green Deployment

Zero-downtime deployments:

```typescript
const bot = await bot.create({
  name: 'Blue-Green Bot',
  deployment: {
    strategy: 'blue-green',
    validation: {
      healthCheck: true,
      smokeTests: true,
      duration: 300, // Validate for 5 minutes
    },
    switchover: 'automatic', // or 'manual'
  },
})
```

## Documentation Best Practices

### Self-Documenting Code

Write clear, descriptive code:

```typescript
const orderProcessingBot = await bot.create({
  name: 'Order Processing Bot',
  task: 'Process customer orders from queue to fulfillment',
  capabilities: [
    'order_validation', // Validate order data and customer info
    'inventory_check', // Verify product availability
    'payment_processing', // Process payment through gateway
    'fulfillment_creation', // Create fulfillment order
  ],
  handler: async (order) => {
    // 1. Validate order data
    const validation = await validateOrder(order)
    if (!validation.valid) {
      throw new Error(`Invalid order: ${validation.errors}`)
    }

    // 2. Check inventory
    const available = await checkInventory(order.items)
    if (!available) {
      throw new Error('Insufficient inventory')
    }

    // 3. Process payment
    const payment = await processPayment(order.payment)
    if (!payment.success) {
      throw new Error(`Payment failed: ${payment.error}`)
    }

    // 4. Create fulfillment
    const fulfillment = await createFulfillment(order)

    return { status: 'completed', fulfillment }
  },
})
```

### API Documentation

Document your bot's API:

````typescript
/**
 * Email Notification Bot
 *
 * Sends email notifications for various events
 *
 * @example
 * ```typescript
 * await emailBot.execute({
 *   to: 'user@example.com',
 *   template: 'order_confirmation',
 *   data: { orderId: '123', total: 99.99 }
 * })
 * ```
 */
const emailBot = await bot.create({
  name: 'Email Bot',
  // ... configuration
})
````

## Common Pitfalls to Avoid

### 1. No Error Handling

```typescript
// Bad
const badBot = await bot.create({
  handler: async (task) => {
    return await riskyOperation(task) // Unhandled errors!
  },
})

// Good
const goodBot = await bot.create({
  handler: async (task) => {
    try {
      return await riskyOperation(task)
    } catch (error) {
      logger.error('Task failed:', error)
      throw error // Re-throw for retry logic
    }
  },
})
```

### 2. Blocking Operations

```typescript
// Bad
const slowBot = await bot.create({
  handler: async (task) => {
    // Blocks for 10 seconds!
    await sleep(10000)
    return processTask(task)
  },
})

// Good
const fastBot = await bot.create({
  handler: async (task) => {
    // Non-blocking async operation
    const result = await processTaskAsync(task)
    return result
  },
})
```

### 3. Memory Leaks

```typescript
// Bad
const leakyBot = await bot.create({
  handler: async (task) => {
    const cache = new Map() // Never cleared!
    cache.set(task.id, task.data)
    return processTask(task)
  },
})

// Good
const cleanBot = await bot.create({
  handler: async (task) => {
    const result = processTask(task)
    // Properly clean up resources
    return result
  },
})
```

### 4. Missing Timeouts

```typescript
// Bad
const hangingBot = await bot.create({
  handler: async (task) => {
    return await externalAPI.call(task) // Can hang forever!
  },
})

// Good
const timedBot = await bot.create({
  timeout: 30000, // 30 second timeout
  handler: async (task) => {
    return await externalAPI.call(task)
  },
})
```

## Checklist

Use this checklist before deploying your bot:

- [ ] Single responsibility principle followed
- [ ] Idempotent operations implemented
- [ ] Error handling and retries configured
- [ ] Logging and metrics enabled
- [ ] Input validation implemented
- [ ] Secrets properly managed
- [ ] Unit tests written
- [ ] Integration tests written
- [ ] Load tested under expected traffic
- [ ] Monitoring and alerts configured
- [ ] Documentation completed
- [ ] Code reviewed by team
- [ ] Deployed to staging first
- [ ] Gradual rollout plan defined

## See Also

- [Getting Started](./getting-started) - Create your first bot
- [Architecture](./architecture) - Bot architecture patterns
- [Troubleshooting](./troubleshooting) - Common issues and solutions
- [API Reference](../api/) - Complete API documentation

---

Continue to [Troubleshooting](./troubleshooting) for common issues and solutions.
