---
$id: https://services.do/examples/service-communication
$type: HowTo
title: Service-to-Service Communication
description: Learn how to implement communication patterns between microservices
keywords: [example, microservices, service-communication, rpc, events, patterns]
author:
  $type: Organization
  name: .do Platform
---

# Service-to-Service Communication

This example demonstrates various patterns for communication between microservices in a distributed system.

## Overview

We'll build an e-commerce system with multiple services that communicate using:

- **Direct RPC calls** - Synchronous request/response
- **Event-driven messaging** - Asynchronous pub/sub
- **Service discovery** - Dynamic service lookup
- **Circuit breakers** - Fault tolerance
- **Distributed tracing** - Request tracking

## Architecture

```
┌─────────────┐      ┌─────────────┐      ┌─────────────┐
│   User      │─────▶│   Order     │─────▶│  Payment    │
│  Service    │      │  Service    │      │  Service    │
└─────────────┘      └─────────────┘      └─────────────┘
       │                    │                     │
       │                    ▼                     │
       │             ┌─────────────┐             │
       └────────────▶│ Inventory   │◀────────────┘
                     │  Service    │
                     └─────────────┘
                            │
                            ▼
                     ┌─────────────┐
                     │Notification │
                     │  Service    │
                     └─────────────┘
```

## 1. User Service

Manages user authentication and profiles.

```typescript
import $, { service, db, send } from 'sdk.do'

export const userService = service({
  name: 'UserService',
  version: '1.0.0',
  routes: {
    // Get user profile
    'GET /users/:id': async (request) => {
      const user = await db.get($.Person, request.params.id)
      if (!user) {
        return Response.json({ error: 'User not found' }, { status: 404 })
      }
      return Response.json(user)
    },

    // Create user
    'POST /users': async (request) => {
      const data = await request.json()

      const user = await db.create($.Person, {
        $type: 'Person',
        name: data.name,
        email: data.email,
        address: data.address,
        createdAt: new Date().toISOString(),
      })

      // Emit user created event
      await send($.User.created, {
        userId: user.$id,
        email: user.email,
        timestamp: new Date().toISOString(),
      })

      return Response.json(user, { status: 201 })
    },

    // Update user address
    'PUT /users/:id/address': async (request) => {
      const data = await request.json()

      const user = await db.update($.Person, request.params.id, {
        address: data.address,
      })

      if (!user) {
        return Response.json({ error: 'User not found' }, { status: 404 })
      }

      // Emit address updated event
      await send($.User.addressUpdated, {
        userId: user.$id,
        address: user.address,
      })

      return Response.json(user)
    },
  },
})
```

## 2. Order Service

Manages orders and orchestrates fulfillment.

```typescript
import $, { service, db, call, discover, send, on } from 'sdk.do'

export const orderService = service({
  name: 'OrderService',
  version: '1.0.0',
  dependencies: [$.UserService, $.InventoryService, $.PaymentService],

  routes: {
    // Create order (orchestrates multiple services)
    'POST /orders': async (request) => {
      const data = await request.json()

      try {
        // 1. Verify user exists
        const userService = await discover($.UserService)
        const user = await call(userService, 'GET /users/:id', {
          id: data.userId,
        })

        if (!user) {
          return Response.json({ error: 'User not found' }, { status: 404 })
        }

        // 2. Check inventory availability
        const inventoryService = await discover($.InventoryService)
        const availability = await call(inventoryService, 'POST /inventory/check', { items: data.items })

        if (!availability.available) {
          return Response.json({ error: 'Items not available', unavailable: availability.unavailable }, { status: 400 })
        }

        // 3. Calculate total
        const total = data.items.reduce((sum, item) => {
          return sum + item.price * item.quantity
        }, 0)

        // 4. Create order
        const order = await db.create($.Order, {
          $type: 'Order',
          user: user.$id,
          items: data.items,
          total,
          status: 'pending',
          createdAt: new Date().toISOString(),
        })

        // 5. Reserve inventory
        await call(inventoryService, 'POST /inventory/reserve', {
          orderId: order.$id,
          items: data.items,
        })

        // 6. Emit order created event
        await send($.Order.created, {
          orderId: order.$id,
          userId: user.$id,
          total,
          items: data.items,
        })

        return Response.json(order, { status: 201 })
      } catch (error) {
        return Response.json({ error: error.message }, { status: 500 })
      }
    },

    // Get order status
    'GET /orders/:id': async (request) => {
      const order = await db.get($.Order, request.params.id)
      if (!order) {
        return Response.json({ error: 'Order not found' }, { status: 404 })
      }
      return Response.json(order)
    },

    // Cancel order
    'DELETE /orders/:id': async (request) => {
      const order = await db.get($.Order, request.params.id)
      if (!order) {
        return Response.json({ error: 'Order not found' }, { status: 404 })
      }

      if (order.status !== 'pending') {
        return Response.json({ error: 'Cannot cancel order in current status' }, { status: 400 })
      }

      // Update order status
      await db.update($.Order, request.params.id, {
        status: 'cancelled',
      })

      // Release inventory
      const inventoryService = await discover($.InventoryService)
      await call(inventoryService, 'POST /inventory/release', {
        orderId: order.$id,
      })

      // Emit cancelled event
      await send($.Order.cancelled, {
        orderId: order.$id,
        reason: 'User cancelled',
      })

      return Response.json({ success: true })
    },
  },
})

// Event handlers
on($.Payment.succeeded, async (event) => {
  // Update order when payment succeeds
  await db.update($.Order, event.data.orderId, {
    status: 'paid',
    paidAt: event.data.timestamp,
  })

  // Emit order paid event
  await send($.Order.paid, {
    orderId: event.data.orderId,
  })
})

on($.Payment.failed, async (event) => {
  // Handle payment failure
  await db.update($.Order, event.data.orderId, {
    status: 'payment_failed',
  })

  // Release inventory
  const inventoryService = await discover($.InventoryService)
  await call(inventoryService, 'POST /inventory/release', {
    orderId: event.data.orderId,
  })
})
```

## 3. Payment Service

Processes payments with retry logic and circuit breaker.

```typescript
import $, { service, db, send, withRetry, withCircuitBreaker } from 'sdk.do'

// Wrap payment processor with circuit breaker
const processPaymentWithBreaker = withCircuitBreaker(
  async (paymentData) => {
    // Call external payment provider
    const response = await fetch('https://payment-provider.example.com/charge', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(paymentData),
    })

    if (!response.ok) {
      throw new Error('Payment failed')
    }

    return response.json()
  },
  {
    threshold: 5, // Open after 5 failures
    timeout: 60000, // Try again after 1 minute
    fallback: async () => {
      // Fallback to alternative provider
      return { status: 'queued', message: 'Payment queued for processing' }
    },
  }
)

export const paymentService = service({
  name: 'PaymentService',
  version: '1.0.0',
  routes: {
    // Process payment
    'POST /payments': async (request) => {
      const data = await request.json()

      try {
        // Process payment with retry logic
        const result = await withRetry(
          () =>
            processPaymentWithBreaker({
              amount: data.amount,
              currency: data.currency,
              source: data.paymentMethod,
              orderId: data.orderId,
            }),
          {
            maxAttempts: 3,
            backoff: 'exponential',
            retryableErrors: ['timeout', 'network'],
          }
        )

        // Save payment record
        const payment = await db.create($.Payment, {
          $type: 'PaymentAction',
          order: data.orderId,
          amount: data.amount,
          currency: data.currency,
          status: 'succeeded',
          transactionId: result.id,
          processedAt: new Date().toISOString(),
        })

        // Emit payment succeeded event
        await send($.Payment.succeeded, {
          paymentId: payment.$id,
          orderId: data.orderId,
          amount: data.amount,
          timestamp: new Date().toISOString(),
        })

        return Response.json(payment, { status: 201 })
      } catch (error) {
        // Save failed payment
        const payment = await db.create($.Payment, {
          $type: 'PaymentAction',
          order: data.orderId,
          amount: data.amount,
          status: 'failed',
          error: error.message,
          attemptedAt: new Date().toISOString(),
        })

        // Emit payment failed event
        await send($.Payment.failed, {
          paymentId: payment.$id,
          orderId: data.orderId,
          error: error.message,
          timestamp: new Date().toISOString(),
        })

        return Response.json({ error: 'Payment processing failed' }, { status: 500 })
      }
    },

    // Get payment status
    'GET /payments/:id': async (request) => {
      const payment = await db.get($.Payment, request.params.id)
      if (!payment) {
        return Response.json({ error: 'Payment not found' }, { status: 404 })
      }
      return Response.json(payment)
    },

    // Refund payment
    'POST /payments/:id/refund': async (request) => {
      const payment = await db.get($.Payment, request.params.id)
      if (!payment) {
        return Response.json({ error: 'Payment not found' }, { status: 404 })
      }

      if (payment.status !== 'succeeded') {
        return Response.json({ error: 'Cannot refund payment in current status' }, { status: 400 })
      }

      // Process refund
      const refund = await processPaymentWithBreaker({
        transactionId: payment.transactionId,
        amount: payment.amount,
        reason: 'customer_request',
      })

      // Update payment status
      await db.update($.Payment, request.params.id, {
        status: 'refunded',
        refundedAt: new Date().toISOString(),
      })

      // Emit refund event
      await send($.Payment.refunded, {
        paymentId: payment.$id,
        orderId: payment.order,
        amount: payment.amount,
      })

      return Response.json({ success: true, refund })
    },
  },
})
```

## 4. Inventory Service

Manages product inventory with locking.

```typescript
import $, { service, db, on, send } from 'sdk.do'

export const inventoryService = service({
  name: 'InventoryService',
  version: '1.0.0',
  routes: {
    // Check availability
    'POST /inventory/check': async (request) => {
      const { items } = await request.json()

      const unavailable = []
      for (const item of items) {
        const inventory = await db.get($.Product, item.productId)
        if (!inventory || inventory.quantity < item.quantity) {
          unavailable.push(item.productId)
        }
      }

      return Response.json({
        available: unavailable.length === 0,
        unavailable,
      })
    },

    // Reserve inventory
    'POST /inventory/reserve': async (request) => {
      const { orderId, items } = await request.json()

      for (const item of items) {
        // Atomic decrement with optimistic locking
        const inventory = await db.get($.Product, item.productId)
        if (inventory.quantity < item.quantity) {
          throw new Error(`Insufficient inventory for ${item.productId}`)
        }

        await db.update($.Product, item.productId, {
          quantity: inventory.quantity - item.quantity,
          reserved: (inventory.reserved || 0) + item.quantity,
        })

        // Create reservation record
        await db.create($.Reservation, {
          $type: 'Reservation',
          order: orderId,
          product: item.productId,
          quantity: item.quantity,
          createdAt: new Date().toISOString(),
          expiresAt: new Date(Date.now() + 15 * 60000).toISOString(), // 15 minutes
        })
      }

      return Response.json({ success: true })
    },

    // Release inventory
    'POST /inventory/release': async (request) => {
      const { orderId } = await request.json()

      // Find reservations for this order
      const reservations = await db.list($.Reservation, {
        where: { order: orderId },
      })

      for (const reservation of reservations) {
        // Return quantity to available inventory
        const inventory = await db.get($.Product, reservation.product)
        await db.update($.Product, reservation.product, {
          quantity: inventory.quantity + reservation.quantity,
          reserved: (inventory.reserved || 0) - reservation.quantity,
        })

        // Delete reservation
        await db.delete($.Reservation, reservation.$id)
      }

      return Response.json({ success: true })
    },

    // Get inventory levels
    'GET /inventory/:productId': async (request) => {
      const inventory = await db.get($.Product, request.params.productId)
      if (!inventory) {
        return Response.json({ error: 'Product not found' }, { status: 404 })
      }
      return Response.json({
        productId: inventory.$id,
        quantity: inventory.quantity,
        reserved: inventory.reserved || 0,
        available: inventory.quantity - (inventory.reserved || 0),
      })
    },
  },
})

// Event handlers
on($.Order.paid, async (event) => {
  // Convert reservations to committed inventory
  const reservations = await db.list($.Reservation, {
    where: { order: event.data.orderId },
  })

  for (const reservation of reservations) {
    const inventory = await db.get($.Product, reservation.product)
    await db.update($.Product, reservation.product, {
      reserved: (inventory.reserved || 0) - reservation.quantity,
      committed: (inventory.committed || 0) + reservation.quantity,
    })
  }

  // Emit inventory committed event
  await send($.Inventory.committed, {
    orderId: event.data.orderId,
  })
})

on($.Order.cancelled, async (event) => {
  // Release reserved inventory
  const inventoryService = await discover($.InventoryService)
  await call(inventoryService, 'POST /inventory/release', {
    orderId: event.data.orderId,
  })
})
```

## 5. Notification Service

Sends notifications based on events.

```typescript
import $, { service, on, send } from 'sdk.do'

export const notificationService = service({
  name: 'NotificationService',
  version: '1.0.0',
  routes: {
    // Manual notification endpoint
    'POST /notifications': async (request) => {
      const { userId, type, message } = await request.json()

      await sendNotification(userId, type, message)

      return Response.json({ success: true })
    },
  },
})

// Event-driven notifications
on($.Order.created, async (event) => {
  await sendNotification(event.data.userId, 'email', {
    subject: 'Order Confirmation',
    template: 'order-confirmation',
    data: {
      orderId: event.data.orderId,
      total: event.data.total,
      items: event.data.items,
    },
  })
})

on($.Payment.succeeded, async (event) => {
  // Get order details
  const order = await db.get($.Order, event.data.orderId)

  await sendNotification(order.user, 'sms', `Payment received for order ${event.data.orderId}. Your order is being processed!`)
})

on($.Payment.failed, async (event) => {
  const order = await db.get($.Order, event.data.orderId)

  await sendNotification(order.user, 'email', {
    subject: 'Payment Failed',
    template: 'payment-failed',
    data: {
      orderId: event.data.orderId,
      error: event.data.error,
    },
  })
})

on($.Order.cancelled, async (event) => {
  const order = await db.get($.Order, event.data.orderId)

  await sendNotification(order.user, 'email', {
    subject: 'Order Cancelled',
    template: 'order-cancelled',
    data: { orderId: event.data.orderId },
  })
})

async function sendNotification(userId: string, type: string, content: any) {
  // Implement notification sending logic
  console.log(`Sending ${type} notification to user ${userId}`)
}
```

## Communication Patterns

### 1. Direct Service Call

```typescript
import { discover, call } from 'sdk.do'

// Discover service
const userService = await discover($.UserService)

// Make direct call
const user = await call(userService, 'GET /users/:id', { id: '123' })
```

### 2. Event-Driven Communication

```typescript
import { send, on } from 'sdk.do'

// Publish event
await send($.Order.created, {
  orderId: '123',
  userId: '456',
  total: 99.99,
})

// Subscribe to event
on($.Order.created, async (event) => {
  console.log('New order:', event.data)
})
```

### 3. Request-Response Pattern

```typescript
// Service A requests data from Service B
const response = await call($.ServiceB, 'GET /data', { id: '123' })

// Process response
if (response.ok) {
  const data = await response.json()
  // Use data...
}
```

### 4. Saga Pattern (Distributed Transaction)

```typescript
import { saga } from 'sdk.do'

const orderSaga = saga({
  steps: [
    {
      service: $.OrderService,
      action: 'createOrder',
      compensate: 'cancelOrder',
    },
    {
      service: $.PaymentService,
      action: 'chargePayment',
      compensate: 'refundPayment',
    },
    {
      service: $.InventoryService,
      action: 'reserveInventory',
      compensate: 'releaseInventory',
    },
  ],
})

// Execute saga
await orderSaga.execute(orderData)
```

## Fault Tolerance

### Circuit Breaker

```typescript
import { withCircuitBreaker } from 'sdk.do'

const callWithBreaker = withCircuitBreaker(
  async () => {
    return await call($.ExternalService, 'GET /data')
  },
  {
    threshold: 5, // Open after 5 failures
    timeout: 60000, // Reset after 1 minute
    fallback: async () => {
      // Return cached data or default
      return getCachedData()
    },
  }
)
```

### Retry Logic

```typescript
import { withRetry } from 'sdk.do'

const result = await withRetry(
  async () => {
    return await call($.UnreliableService, 'GET /data')
  },
  {
    maxAttempts: 3,
    backoff: 'exponential',
    initialDelay: 1000,
    maxDelay: 10000,
  }
)
```

### Timeout

```typescript
import { withTimeout } from 'sdk.do'

try {
  const result = await withTimeout(
    call($.SlowService, 'GET /data'),
    5000 // 5 second timeout
  )
} catch (error) {
  if (error.name === 'TimeoutError') {
    // Handle timeout
  }
}
```

## Distributed Tracing

Enable tracing to track requests across services:

```typescript
import { trace } from 'sdk.do'

// Start trace
const span = trace.start('process-order')

try {
  // Add attributes
  span.setAttribute('userId', userId)
  span.setAttribute('orderId', orderId)

  // Call services (automatically traced)
  const user = await call($.UserService, 'GET /users/:id', { id: userId })
  span.addEvent('user-fetched')

  const payment = await call($.PaymentService, 'POST /payments', paymentData)
  span.addEvent('payment-processed')

  // Mark success
  span.setStatus({ code: 'OK' })
} catch (error) {
  // Mark error
  span.setStatus({ code: 'ERROR', message: error.message })
  span.recordException(error)
} finally {
  // End trace
  span.end()
}
```

## Testing Service Communication

```typescript
// Mock service for testing
import { mockService } from 'sdk.do/testing'

// Mock UserService
mockService($.UserService, {
  'GET /users/:id': async (request) => {
    return Response.json({
      $id: request.params.id,
      name: 'Test User',
      email: 'test@example.com',
    })
  },
})

// Test OrderService
const response = await call($.OrderService, 'POST /orders', orderData)
```

## Next Steps

- [Deploy Service](./deploy-service.mdx) - Deploy services to production
- [Service Management](../docs/management.mdx) - Monitor and scale services
- [API Reference](../api/) - Complete API documentation

## Best Practices

1. **Use Events for Loose Coupling**: Emit events for state changes
2. **Implement Idempotency**: Make operations safe to retry
3. **Add Circuit Breakers**: Protect against cascading failures
4. **Trace Requests**: Enable distributed tracing
5. **Handle Failures Gracefully**: Implement fallbacks and retries
6. **Version APIs**: Use semantic versioning for service APIs
7. **Monitor Communication**: Track latency and error rates
8. **Use Service Discovery**: Avoid hardcoded service URLs
