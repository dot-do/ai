---
$id: https://on.do/docs/getting-started
$type: TechArticle
title: Getting Started with on.do
description: Install and configure event listeners for Business-as-Code applications
keywords: [on, event-listeners, getting-started, installation, setup]
author:
  $type: Organization
  name: .do Platform
---

# Getting Started

Get started with event listeners in under 5 minutes. Learn how to subscribe to business events and build reactive applications.

## Installation

Install the SDK:

```bash
pnpm add sdk.do
```

Or use npm/yarn:

```bash
npm install sdk.do
# or
yarn add sdk.do
```

## Basic Setup

Import the `on` function from the SDK:

```typescript
import { on } from 'sdk.do'
```

That's it! You're ready to start listening to events.

## Your First Event Listener

Let's create a simple event listener:

### 1. Create an Event Listener

```typescript
import { on } from 'sdk.do'

// Listen for user registration events
on('User.registered', async (event) => {
  console.log('New user registered:', event.data.email)

  // Send welcome email
  await sendWelcomeEmail(event.data.email)

  // Create default preferences
  await createUserPreferences(event.data.id)
})
```

### 2. Publish an Event

In another part of your application, publish the event:

```typescript
import { send } from 'sdk.do'

async function registerUser(userData) {
  // Create user in database
  const user = await createUser(userData)

  // Publish registration event
  await send('User.registered', {
    id: user.id,
    email: user.email,
    name: user.name,
    registeredAt: new Date(),
  })

  return user
}
```

### 3. Run Your Application

When you run your application:

1. The event listener is registered on startup
2. When `registerUser()` is called, it publishes `User.registered`
3. The listener receives the event and executes the handler
4. Welcome email is sent and preferences are created

```typescript
// Register a new user
await registerUser({
  email: 'user@example.com',
  name: 'John Doe',
  password: 'secure-password',
})

// Console output: "New user registered: user@example.com"
// Welcome email is sent
```

## Event Naming Convention

The `on` function uses the `Object.Action` naming pattern:

- **Object**: The business entity (capitalized, e.g., `Order`, `User`, `Payment`)
- **Action**: Past-tense verb (e.g., `created`, `updated`, `shipped`, `completed`)

### Good Examples

```typescript
on('Order.created', handler) // ✅ Clear and semantic
on('Payment.completed', handler) // ✅ Past tense
on('User.registered', handler) // ✅ Business action
on('Product.outOfStock', handler) // ✅ State change
```

### Bad Examples

```typescript
on('order_create', handler) // ❌ Snake case
on('createOrder', handler) // ❌ Camel case, present tense
on('PAYMENT_DONE', handler) // ❌ Screaming case
on('user-new', handler) // ❌ Kebab case
```

## Event Structure

Events follow a standard structure:

```typescript
interface Event<T = any> {
  type: string // Event name (e.g., 'Order.created')
  data: T // Event payload
  metadata?: {
    timestamp: Date
    source?: string
    correlationId?: string
    causationId?: string
    userId?: string
  }
}
```

### Example Event

```typescript
{
  type: 'Order.created',
  data: {
    id: '12345',
    customer: 'acme-corp',
    items: [
      { product: 'widget', quantity: 10, price: 99.99 }
    ],
    total: 999.90
  },
  metadata: {
    timestamp: new Date('2025-01-15T10:30:00Z'),
    source: 'checkout-service',
    correlationId: 'session-abc123',
    userId: 'user-456'
  }
}
```

## Multiple Event Listeners

You can register multiple listeners for the same event:

```typescript
// Send confirmation email
on('Order.created', async (event) => {
  await sendOrderConfirmation(event.data)
})

// Update analytics
on('Order.created', async (event) => {
  await trackOrderMetrics(event.data)
})

// Notify warehouse
on('Order.created', async (event) => {
  await notifyWarehouse(event.data)
})
```

All three handlers execute in parallel when `Order.created` is published.

## Pattern Matching

Listen to multiple related events using patterns:

```typescript
// Listen to all Order events
on('Order.*', async (event) => {
  await auditLog(event.type, event.data)
})

// Listen to specific events
on(['Order.created', 'Order.updated'], async (event) => {
  await syncToAnalytics(event)
})

// Listen to all events
on('*', async (event) => {
  await logAllEvents(event)
})
```

## Event Filtering

Filter events based on data properties:

```typescript
// Only process high-value orders
on(
  'Order.created',
  {
    filter: (event) => event.data.total > 1000,
  },
  async (event) => {
    await flagForReview(event.data)
  }
)

// Only process enterprise customers
on(
  'Order.created',
  {
    filter: (event) => event.data.customer.tier === 'enterprise',
  },
  async (event) => {
    await priorityProcessing(event.data)
  }
)
```

## Error Handling

Handle errors gracefully in event listeners:

```typescript
on('Order.created', async (event) => {
  try {
    await processOrder(event.data)
  } catch (error) {
    console.error('Failed to process order:', error)

    // Publish error event
    await send('Order.processingFailed', {
      orderId: event.data.id,
      error: error.message,
      timestamp: new Date(),
    })

    // Don't re-throw to allow other handlers to continue
  }
})
```

## Unsubscribing

Remove event listeners when no longer needed:

```typescript
// Save unsubscribe function
const unsubscribe = on('Order.created', handler)

// Later, unsubscribe
unsubscribe()

// Or with timeout
const unsubscribe = on('Order.created', handler)
setTimeout(() => unsubscribe(), 60000) // Remove after 1 minute
```

## TypeScript Support

Define typed events for better IDE support:

```typescript
import type { Event } from 'sdk.do'

// Define event type
interface OrderCreatedEvent
  extends Event<{
    id: string
    customer: string
    items: Array<{
      product: string
      quantity: number
      price: number
    }>
    total: number
  }> {
  type: 'Order.created'
}

// Type-safe listener
on('Order.created', async (event: OrderCreatedEvent) => {
  // TypeScript knows event.data structure
  console.log(`Order ${event.data.id} total: $${event.data.total}`)
})
```

## Semantic Patterns

Use the semantic `$` proxy for type-safe subscriptions:

```typescript
import $, { on } from 'sdk.do'

// Semantic event patterns
on($.Order.created, async (event) => {
  console.log(`Order ${event.data.$id} created`)
})

on($.Payment.completed, async (event) => {
  console.log(`Payment of $${event.data.amount} completed`)
})

on($.User.registered, async (event) => {
  console.log(`User ${event.data.email} registered`)
})
```

## Common Event Patterns

### Lifecycle Events

```typescript
on('Order.created', handler) // Entity created
on('Order.updated', handler) // Entity modified
on('Order.deleted', handler) // Entity removed
on('Order.archived', handler) // Entity archived
```

### State Change Events

```typescript
on('Order.submitted', handler) // Submitted by customer
on('Order.validated', handler) // Validated by system
on('Order.confirmed', handler) // Confirmed and paid
on('Order.shipped', handler) // Shipped from warehouse
on('Order.delivered', handler) // Delivered to customer
on('Order.completed', handler) // Process completed
on('Order.cancelled', handler) // Cancelled by user
```

### Action Events

```typescript
on('Payment.requested', handler) // Payment requested
on('Payment.authorized', handler) // Payment authorized
on('Payment.captured', handler) // Payment captured
on('Payment.completed', handler) // Payment completed
on('Payment.failed', handler) // Payment failed
on('Payment.refunded', handler) // Payment refunded
```

## Testing Event Listeners

Test event listeners with mock events:

```typescript
import { on, send } from 'sdk.do'
import { expect, test } from 'vitest'

test('handles order creation', async () => {
  let receivedEvent

  // Register test listener
  on('Order.created', async (event) => {
    receivedEvent = event
  })

  // Publish event
  await send('Order.created', {
    id: '12345',
    total: 100,
  })

  // Assert
  expect(receivedEvent.data.id).toBe('12345')
  expect(receivedEvent.data.total).toBe(100)
})
```

## Configuration

Configure event listener behavior (optional):

```typescript
import { configureEvents } from 'sdk.do'

configureEvents({
  // Maximum retries for failed handlers
  maxRetries: 3,

  // Retry delay in milliseconds
  retryDelay: 1000,

  // Enable event persistence
  persist: true,

  // Event storage backend
  storage: 'redis', // or 'memory', 'postgres', etc.

  // Enable debug logging
  debug: true,
})
```

### Environment Variables

Configure via environment variables:

```bash
# Event bus backend
EVENT_BUS_BACKEND=redis

# Redis connection (if using Redis)
REDIS_URL=redis://localhost:6379

# Enable event persistence
EVENT_PERSIST=true

# Enable debug logging
EVENT_DEBUG=true
```

## Next Steps

Now that you understand the basics, explore:

- [Event Patterns](./patterns) - Common listener patterns
- [Event Filtering](./filtering) - Advanced filtering techniques
- [API Reference](../api/) - Complete API documentation
- [Examples](../examples/) - Real-world usage examples

## Best Practices

### 1. Register Listeners on Startup

Register all listeners when your application starts, before handling requests:

```typescript
// Good - register on startup
async function initializeApp() {
  // Register listeners
  on('Order.created', handleOrderCreated)
  on('Payment.completed', handlePaymentCompleted)

  // Then start server
  await startServer()
}

// Bad - register during request handling
app.post('/orders', async (req, res) => {
  on('Order.created', handler) // ❌ Don't do this
})
```

### 2. Use Semantic Naming

Always use clear `Object.Action` patterns:

```typescript
// Good
on('Order.created', handler)
on('Payment.completed', handler)

// Bad
on('order_create', handler)
on('payment-done', handler)
```

### 3. Keep Handlers Focused

Each handler should do one thing well:

```typescript
// Good - focused handlers
on('Order.created', validateOrder)
on('Order.validated', requestPayment)
on('Payment.completed', fulfillOrder)

// Bad - kitchen sink handler
on('Order.created', async (event) => {
  // validates, processes payment, fulfills, ships...
})
```

### 4. Handle Errors Gracefully

Don't let errors break the event chain:

```typescript
on('Order.created', async (event) => {
  try {
    await processOrder(event.data)
  } catch (error) {
    console.error('Failed:', error)
    await send('Order.failed', {
      orderId: event.data.id,
      error: error.message,
    })
  }
})
```

### 5. Use TypeScript Types

Define event interfaces for type safety:

```typescript
interface OrderCreatedEvent
  extends Event<{
    id: string
    total: number
  }> {
  type: 'Order.created'
}

on('Order.created', async (event: OrderCreatedEvent) => {
  // Type-safe handler
})
```

### 6. Track Correlations

Pass correlation IDs through event chains:

```typescript
on('Order.created', async (event) => {
  await send('Payment.requested', paymentData, {
    correlationId: event.metadata.correlationId,
  })
})
```

## Troubleshooting

### Events Not Being Received

1. **Check listener is registered before events are published**:

```typescript
// ❌ Bad - listener registered after event
await send('Order.created', data)
on('Order.created', handler) // Too late!

// ✅ Good - listener registered first
on('Order.created', handler)
await send('Order.created', data)
```

2. **Check event names match exactly** (case-sensitive):

```typescript
// ❌ Won't match
on('order.created', handler)
await send('Order.created', data)

// ✅ Matches
on('Order.created', handler)
await send('Order.created', data)
```

3. **Enable debug logging**:

```typescript
import { configureEvents } from 'sdk.do'

configureEvents({ debug: true })
```

### Handler Errors

If a handler throws an error, the event bus will retry (if configured):

```typescript
on('Order.created', async (event) => {
  try {
    await riskyOperation(event.data)
  } catch (error) {
    console.error('Handler failed:', error)

    // Option 1: Re-throw to trigger retry
    throw error

    // Option 2: Publish error event and continue
    await send('Order.processingFailed', {
      orderId: event.data.id,
      error: error.message,
    })
  }
})
```

## Resources

- [Event Patterns Documentation](./patterns)
- [Event Filtering Documentation](./filtering)
- [API Reference](../api/)
- [Examples](../examples/)
- [sdk.do Documentation](https://sdk.do)
- [events.do Documentation](https://events.do)

---

Ready to dive deeper? Continue to [Event Patterns](./patterns) to explore common listener patterns.
